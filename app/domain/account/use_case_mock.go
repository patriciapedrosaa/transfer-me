// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package account

import (
	"context"
	"github.com/patriciapedrosaa/transfer-me/app/domain/entities"
	"sync"
)

// Ensure, that UseCaseMock does implement UseCase.
// If this is not the case, regenerate this file with moq.
var _ UseCase = &UseCaseMock{}

// UseCaseMock is a mock implementation of UseCase.
//
// 	func TestSomethingThatUsesUseCase(t *testing.T) {
//
// 		// make and configure a mocked UseCase
// 		mockedUseCase := &UseCaseMock{
// 			CreateFunc: func(ctx context.Context, input CreateAccountInput) (entities.Account, error) {
// 				panic("mock out the Create method")
// 			},
// 			GetAccountsFunc: func(ctx context.Context) ([]entities.Account, error) {
// 				panic("mock out the GetAccounts method")
// 			},
// 			GetBalanceFunc: func(ctx context.Context, id string) (int, error) {
// 				panic("mock out the GetBalance method")
// 			},
// 			GetByCpfFunc: func(ctx context.Context, cpf string) (entities.Account, error) {
// 				panic("mock out the GetByCpf method")
// 			},
// 			GetByIdFunc: func(ctx context.Context, id string) (entities.Account, error) {
// 				panic("mock out the GetById method")
// 			},
// 			UpdateBalanceFunc: func(ctx context.Context, originAccountId string, destinationAccountId string, amount int) error {
// 				panic("mock out the UpdateBalance method")
// 			},
// 		}
//
// 		// use mockedUseCase in code that requires UseCase
// 		// and then make assertions.
//
// 	}
type UseCaseMock struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, input CreateAccountInput) (entities.Account, error)

	// GetAccountsFunc mocks the GetAccounts method.
	GetAccountsFunc func(ctx context.Context) ([]entities.Account, error)

	// GetBalanceFunc mocks the GetBalance method.
	GetBalanceFunc func(ctx context.Context, id string) (int, error)

	// GetByCpfFunc mocks the GetByCpf method.
	GetByCpfFunc func(ctx context.Context, cpf string) (entities.Account, error)

	// GetByIdFunc mocks the GetById method.
	GetByIdFunc func(ctx context.Context, id string) (entities.Account, error)

	// UpdateBalanceFunc mocks the UpdateBalance method.
	UpdateBalanceFunc func(ctx context.Context, originAccountId string, destinationAccountId string, amount int) error

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input CreateAccountInput
		}
		// GetAccounts holds details about calls to the GetAccounts method.
		GetAccounts []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetBalance holds details about calls to the GetBalance method.
		GetBalance []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// GetByCpf holds details about calls to the GetByCpf method.
		GetByCpf []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Cpf is the cpf argument value.
			Cpf string
		}
		// GetById holds details about calls to the GetById method.
		GetById []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// UpdateBalance holds details about calls to the UpdateBalance method.
		UpdateBalance []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OriginAccountId is the originAccountId argument value.
			OriginAccountId string
			// DestinationAccountId is the destinationAccountId argument value.
			DestinationAccountId string
			// Amount is the amount argument value.
			Amount int
		}
	}
	lockCreate        sync.RWMutex
	lockGetAccounts   sync.RWMutex
	lockGetBalance    sync.RWMutex
	lockGetByCpf      sync.RWMutex
	lockGetById       sync.RWMutex
	lockUpdateBalance sync.RWMutex
}

// Create calls CreateFunc.
func (mock *UseCaseMock) Create(ctx context.Context, input CreateAccountInput) (entities.Account, error) {
	callInfo := struct {
		Ctx   context.Context
		Input CreateAccountInput
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	if mock.CreateFunc == nil {
		var (
			accountOut entities.Account
			errOut     error
		)
		return accountOut, errOut
	}
	return mock.CreateFunc(ctx, input)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//     len(mockedUseCase.CreateCalls())
func (mock *UseCaseMock) CreateCalls() []struct {
	Ctx   context.Context
	Input CreateAccountInput
} {
	var calls []struct {
		Ctx   context.Context
		Input CreateAccountInput
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// GetAccounts calls GetAccountsFunc.
func (mock *UseCaseMock) GetAccounts(ctx context.Context) ([]entities.Account, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAccounts.Lock()
	mock.calls.GetAccounts = append(mock.calls.GetAccounts, callInfo)
	mock.lockGetAccounts.Unlock()
	if mock.GetAccountsFunc == nil {
		var (
			accountsOut []entities.Account
			errOut      error
		)
		return accountsOut, errOut
	}
	return mock.GetAccountsFunc(ctx)
}

// GetAccountsCalls gets all the calls that were made to GetAccounts.
// Check the length with:
//     len(mockedUseCase.GetAccountsCalls())
func (mock *UseCaseMock) GetAccountsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetAccounts.RLock()
	calls = mock.calls.GetAccounts
	mock.lockGetAccounts.RUnlock()
	return calls
}

// GetBalance calls GetBalanceFunc.
func (mock *UseCaseMock) GetBalance(ctx context.Context, id string) (int, error) {
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetBalance.Lock()
	mock.calls.GetBalance = append(mock.calls.GetBalance, callInfo)
	mock.lockGetBalance.Unlock()
	if mock.GetBalanceFunc == nil {
		var (
			nOut   int
			errOut error
		)
		return nOut, errOut
	}
	return mock.GetBalanceFunc(ctx, id)
}

// GetBalanceCalls gets all the calls that were made to GetBalance.
// Check the length with:
//     len(mockedUseCase.GetBalanceCalls())
func (mock *UseCaseMock) GetBalanceCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockGetBalance.RLock()
	calls = mock.calls.GetBalance
	mock.lockGetBalance.RUnlock()
	return calls
}

// GetByCpf calls GetByCpfFunc.
func (mock *UseCaseMock) GetByCpf(ctx context.Context, cpf string) (entities.Account, error) {
	callInfo := struct {
		Ctx context.Context
		Cpf string
	}{
		Ctx: ctx,
		Cpf: cpf,
	}
	mock.lockGetByCpf.Lock()
	mock.calls.GetByCpf = append(mock.calls.GetByCpf, callInfo)
	mock.lockGetByCpf.Unlock()
	if mock.GetByCpfFunc == nil {
		var (
			accountOut entities.Account
			errOut     error
		)
		return accountOut, errOut
	}
	return mock.GetByCpfFunc(ctx, cpf)
}

// GetByCpfCalls gets all the calls that were made to GetByCpf.
// Check the length with:
//     len(mockedUseCase.GetByCpfCalls())
func (mock *UseCaseMock) GetByCpfCalls() []struct {
	Ctx context.Context
	Cpf string
} {
	var calls []struct {
		Ctx context.Context
		Cpf string
	}
	mock.lockGetByCpf.RLock()
	calls = mock.calls.GetByCpf
	mock.lockGetByCpf.RUnlock()
	return calls
}

// GetById calls GetByIdFunc.
func (mock *UseCaseMock) GetById(ctx context.Context, id string) (entities.Account, error) {
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetById.Lock()
	mock.calls.GetById = append(mock.calls.GetById, callInfo)
	mock.lockGetById.Unlock()
	if mock.GetByIdFunc == nil {
		var (
			accountOut entities.Account
			errOut     error
		)
		return accountOut, errOut
	}
	return mock.GetByIdFunc(ctx, id)
}

// GetByIdCalls gets all the calls that were made to GetById.
// Check the length with:
//     len(mockedUseCase.GetByIdCalls())
func (mock *UseCaseMock) GetByIdCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockGetById.RLock()
	calls = mock.calls.GetById
	mock.lockGetById.RUnlock()
	return calls
}

// UpdateBalance calls UpdateBalanceFunc.
func (mock *UseCaseMock) UpdateBalance(ctx context.Context, originAccountId string, destinationAccountId string, amount int) error {
	callInfo := struct {
		Ctx                  context.Context
		OriginAccountId      string
		DestinationAccountId string
		Amount               int
	}{
		Ctx:                  ctx,
		OriginAccountId:      originAccountId,
		DestinationAccountId: destinationAccountId,
		Amount:               amount,
	}
	mock.lockUpdateBalance.Lock()
	mock.calls.UpdateBalance = append(mock.calls.UpdateBalance, callInfo)
	mock.lockUpdateBalance.Unlock()
	if mock.UpdateBalanceFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.UpdateBalanceFunc(ctx, originAccountId, destinationAccountId, amount)
}

// UpdateBalanceCalls gets all the calls that were made to UpdateBalance.
// Check the length with:
//     len(mockedUseCase.UpdateBalanceCalls())
func (mock *UseCaseMock) UpdateBalanceCalls() []struct {
	Ctx                  context.Context
	OriginAccountId      string
	DestinationAccountId string
	Amount               int
} {
	var calls []struct {
		Ctx                  context.Context
		OriginAccountId      string
		DestinationAccountId string
		Amount               int
	}
	mock.lockUpdateBalance.RLock()
	calls = mock.calls.UpdateBalance
	mock.lockUpdateBalance.RUnlock()
	return calls
}
